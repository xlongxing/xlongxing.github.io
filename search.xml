<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LFM算法实现</title>
    <url>/2023/08/30/LFM%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="基于矩阵分解的cf算法实现一lfm">基于矩阵分解的CF算法实现（一）：LFM</h2>
<p>LFM也就是前面提到的Funk SVD矩阵分解</p>
<h4 id="lfm原理解析">LFM原理解析</h4>
<p>LFM(latent factor model)隐语义模型核心思想是通过隐含特征联系用户和物品，如下图：</p>
<p><img src="https://pic.imgdb.cn/item/64ef1a8b661c6c8e54b98ebf.png" /></p>
<ul>
<li>P矩阵是User-LF矩阵，即用户和隐含特征矩阵。LF有三个，表示共总有三个隐含特征。</li>
<li>Q矩阵是LF-Item矩阵，即隐含特征和物品的矩阵</li>
<li>R矩阵是User-Item矩阵，有P*Q得来</li>
<li><p>能处理稀疏评分矩阵 <span id="more"></span> 利用矩阵分解技术，将原始User-Item的评分矩阵（稠密/稀疏）分解为P和Q矩阵，然后利用<span class="math inline">\(P*Q\)</span>还原出User-Item评分矩阵<span class="math inline">\(R\)</span>。整个过程相当于降维处理，其中：</p></li>
<li><p>矩阵值<span class="math inline">\(P_{11}\)</span>表示用户1对隐含特征1的权重值</p></li>
<li><p>矩阵值<span class="math inline">\(Q_{11}\)</span>表示隐含特征1在物品1上的权重值</p></li>
<li><p>矩阵值<span class="math inline">\(R_{11}\)</span>就表示预测的用户1对物品1的评分，且<span class="math inline">\(R_{11}=\vec{P_{1,k}}\cdot \vec{Q_{k,1}}\)</span></p>
<p><img src="https://pic.imgdb.cn/item/64ef1c2c661c6c8e54b9db03.png" /></p></li>
</ul>
<p>利用LFM预测用户对物品的评分，<span class="math inline">\(k\)</span>表示隐含特征数量： <span class="math display">\[
\begin{split}
\hat {r}_{ui} &amp;=\vec {p_{uk}}\cdot \vec {q_{ik}}
\\&amp;={\sum_{k=1}}^k p_{uk}q_{ik}
\end{split}
\]</span> 因此最终，我们的目标也就是要求出P矩阵和Q矩阵及其当中的每一个值，然后再对用户-物品的评分进行预测。</p>
<h4 id="损失函数">损失函数</h4>
<p>同样对于评分预测我们利用平方差来构建损失函数： <span class="math display">\[
\begin{split}
Cost &amp;= \sum_{u,i\in R} (r_{ui}-\hat{r}_{ui})^2
\\&amp;=\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2
\end{split}
\]</span> 加入L2正则化： <span class="math display">\[
Cost = \sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)
\]</span> 对损失函数求偏导： <span class="math display">\[
\begin{split}
\cfrac {\partial}{\partial p_{uk}}Cost &amp;= \cfrac {\partial}{\partial p_{uk}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]
\\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}
\\\\
\cfrac {\partial}{\partial q_{ik}}Cost &amp;= \cfrac {\partial}{\partial q_{ik}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]
\\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-p_{uk}) + 2\lambda q_{ik}
\end{split}
\]</span></p>
<h4 id="随机梯度下降法优化">随机梯度下降法优化</h4>
<p>梯度下降更新参数<span class="math inline">\(p_{uk}\)</span>： <span class="math display">\[
\begin{split}
p_{uk}&amp;:=p_{uk} - \alpha\cfrac {\partial}{\partial p_{uk}}Cost
\\&amp;:=p_{uk}-\alpha [2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}]
\\&amp;:=p_{uk}+\alpha [\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda p_{uk}]
\end{split}
\]</span> 同理： <span class="math display">\[
\begin{split}
q_{ik}&amp;:=q_{ik} + \alpha[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda q_{ik}]
\end{split}
\]</span> <strong>随机梯度下降：</strong> 向量乘法 每一个分量相乘 求和 <span class="math display">\[
\begin{split}
&amp;p_{uk}:=p_{uk}+\alpha [(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda_1 p_{uk}]
\\&amp;q_{ik}:=q_{ik} + \alpha[(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda_2 q_{ik}]
\end{split}
\]</span> 由于P矩阵和Q矩阵是两个不同的矩阵，通常分别采取不同的正则参数，如λ1和λ2</p>
<p><strong>算法实现</strong>l</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">LFM Model</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评分预测    1-5</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha, reg_p, reg_q, number_LatentFactors=<span class="number">10</span>, number_epochs=<span class="number">10</span>, columns=[<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;iid&quot;</span>, <span class="string">&quot;rating&quot;</span>]</span>):</span><br><span class="line">        self.alpha = alpha <span class="comment"># 学习率</span></span><br><span class="line">        self.reg_p = reg_p    <span class="comment"># P矩阵正则</span></span><br><span class="line">        self.reg_q = reg_q    <span class="comment"># Q矩阵正则</span></span><br><span class="line">        self.number_LatentFactors = number_LatentFactors  <span class="comment"># 隐式类别数量</span></span><br><span class="line">        self.number_epochs = number_epochs    <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, dataset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        fit dataset</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.dataset = pd.DataFrame(dataset)</span><br><span class="line"></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line"></span><br><span class="line">        self.globalMean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line"></span><br><span class="line">        self.P, self.Q = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_matrix</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化P和Q矩阵，同时为设置0，1之间的随机值作为初始值</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># User-LF</span></span><br><span class="line">        P = <span class="built_in">dict</span>(<span class="built_in">zip</span>(</span><br><span class="line">            self.users_ratings.index,</span><br><span class="line">            np.random.rand(<span class="built_in">len</span>(self.users_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="comment"># Item-LF</span></span><br><span class="line">        Q = <span class="built_in">dict</span>(<span class="built_in">zip</span>(</span><br><span class="line">            self.items_ratings.index,</span><br><span class="line">            np.random.rand(<span class="built_in">len</span>(self.items_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        使用随机梯度下降，优化结果</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        P, Q = self._init_matrix()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;iter%d&quot;</span>%i)</span><br><span class="line">            error_list = []</span><br><span class="line">            <span class="keyword">for</span> uid, iid, r_ui <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                <span class="comment"># User-LF P</span></span><br><span class="line">                <span class="comment">## Item-LF Q</span></span><br><span class="line">                v_pu = P[uid] <span class="comment">#用户向量</span></span><br><span class="line">                v_qi = Q[iid] <span class="comment">#物品向量</span></span><br><span class="line">                err = np.float32(r_ui - np.dot(v_pu, v_qi))</span><br><span class="line"></span><br><span class="line">                v_pu += self.alpha * (err * v_qi - self.reg_p * v_pu)</span><br><span class="line">                v_qi += self.alpha * (err * v_pu - self.reg_q * v_qi)</span><br><span class="line">                </span><br><span class="line">                P[uid] = v_pu </span><br><span class="line">                Q[iid] = v_qi</span><br><span class="line"></span><br><span class="line">                <span class="comment"># for k in range(self.number_of_LatentFactors):</span></span><br><span class="line">                <span class="comment">#     v_pu[k] += self.alpha*(err*v_qi[k] - self.reg_p*v_pu[k])</span></span><br><span class="line">                <span class="comment">#     v_qi[k] += self.alpha*(err*v_pu[k] - self.reg_q*v_qi[k])</span></span><br><span class="line"></span><br><span class="line">                error_list.append(err ** <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(np.sqrt(np.mean(error_list)))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, uid, iid</span>):</span><br><span class="line">        <span class="comment"># 如果uid或iid不在，我们使用全剧平均分作为预测结果返回</span></span><br><span class="line">        <span class="keyword">if</span> uid <span class="keyword">not</span> <span class="keyword">in</span> self.users_ratings.index <span class="keyword">or</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">return</span> self.globalMean</span><br><span class="line"></span><br><span class="line">        p_u = self.P[uid]</span><br><span class="line">        q_i = self.Q[iid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.dot(p_u, q_i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self,testset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;预测测试集数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dtype = [(<span class="string">&quot;userId&quot;</span>, np.int32), (<span class="string">&quot;movieId&quot;</span>, np.int32), (<span class="string">&quot;rating&quot;</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">&quot;datasets/ml-latest-small/ratings.csv&quot;</span>, usecols=<span class="built_in">range</span>(<span class="number">3</span>), dtype=<span class="built_in">dict</span>(dtype))</span><br><span class="line"></span><br><span class="line">    lfm = LFM(<span class="number">0.02</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">10</span>, <span class="number">100</span>, [<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;movieId&quot;</span>, <span class="string">&quot;rating&quot;</span>])</span><br><span class="line">    lfm.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = <span class="built_in">input</span>(<span class="string">&quot;uid: &quot;</span>)</span><br><span class="line">        iid = <span class="built_in">input</span>(<span class="string">&quot;iid: &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(lfm.predict(<span class="built_in">int</span>(uid), <span class="built_in">int</span>(iid)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>传统推荐模型</category>
      </categories>
      <tags>
        <tag>矩阵分解</tag>
        <tag>SVD</tag>
        <tag>LFM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于回归模型的协同过滤推荐</title>
    <url>/2023/08/30/%E5%9F%BA%E4%BA%8E%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="基于回归模型的协同过滤推荐"><a href="#基于回归模型的协同过滤推荐" class="headerlink" title="基于回归模型的协同过滤推荐"></a>基于回归模型的协同过滤推荐</h2><p>如果我们将评分看作是一个连续的值而不是离散的值，那么就可以借助线性回归思想来预测目标用户对某物品的评分。其中一种实现策略被称为Baseline（基准预测）。</p>
<h4 id="Baseline：基准预测"><a href="#Baseline：基准预测" class="headerlink" title="Baseline：基准预测"></a>Baseline：基准预测</h4><p>Baseline设计思想基于以下的假设：</p>
<ul>
<li>有些用户的评分普遍高于其他用户，有些用户的评分普遍低于其他用户。比如有些用户天生愿意给别人好评，心慈手软，比较好说话，而有的人就比较苛刻，总是评分不超过3分（5分满分）</li>
<li>一些物品的评分普遍高于其他物品，一些物品的评分普遍低于其他物品。比如一些物品一被生产便决定了它的地位，有的比较受人们欢迎，有的则被人嫌弃。</li>
</ul>
<p>这个用户或物品普遍高于或低于平均值的差值，我们称为偏置(bias)</p>
<span id="more"></span>

<p><strong>Baseline目标：</strong></p>
<ul>
<li>找出每个用户普遍高于或低于他人的偏置值$b_u$</li>
<li>找出每件物品普遍高于或低于其他物品的偏置值$b_i$</li>
<li>我们的目标也就转化为寻找最优的$b_u$和$b_i$</li>
</ul>
<p>使用Baseline的算法思想预测评分的步骤如下：</p>
<ul>
<li><p>计算所有电影的平均评分$\mu$（即全局平均评分）</p>
</li>
<li><p>计算每个用户评分与平均评分$\mu$的偏置值$b_u$</p>
</li>
<li><p>计算每部电影所接受的评分与平均评分$\mu$的偏置值$b_i$</p>
</li>
<li><p>预测用户对电影的评分：$\hat{r}<em>{ui} &#x3D; b</em>{ui} &#x3D; \mu + b_u + b_i$</p>
</li>
</ul>
<p>举例：</p>
<p>​	比如我们想通过Baseline来预测用户A对电影“阿甘正传”的评分，那么首先计算出整个评分数据集的平均评分$\mu$是3.5分；而用户A是一个比较苛刻的用户，他的评分比较严格，普遍比平均评分低0.5分，即用户A的偏置值$b_i$是-0.5；而电影“阿甘正传”是一部比较热门而且备受好评的电影，它的评分普遍比平均评分要高1.2分，那么电影“阿甘正传”的偏置值$b_i$是+1.2，因此就可以预测出用户A对电影“阿甘正传”的评分为：$3.5+(-0.5)+1.2$，也就是4.2分。</p>
<p>对于所有电影的平均评分$\mu$是直接能计算出的，因此问题在于要测出每个用户的$b_u$值和每部电影的$b_i$的值。对于线性回归问题，我们可以利用平方差构建损失函数如下：<br>$$<br>\begin{split}<br>Cost &amp;&#x3D; \sum_{u,i\in R}(r_{ui}-\hat{r}<em>{ui})^2<br>\&amp;&#x3D;\sum</em>{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2<br>\end{split}<br>$$<br><img src="/img/%E5%81%8F%E7%BD%AE.png"></p>
<p>加入L2正则化：<br>$$<br>Cost&#x3D;\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>公式解析：</p>
<ul>
<li>公式第一部分$ \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2$是用来寻找与已知评分数据拟合最好的$b_u$和$b_i$</li>
<li>公式第二部分$\lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)$是正则化项，用于避免过拟合现象</li>
</ul>
<p>对于最小过程的求解，我们一般采用<strong>随机梯度下降法</strong>或者<strong>交替最小二乘法</strong>来优化实现。</p>
<h4 id="方法一：随机梯度下降法优化"><a href="#方法一：随机梯度下降法优化" class="headerlink" title="方法一：随机梯度下降法优化"></a>方法一：随机梯度下降法优化</h4><p>使用随机梯度下降优化算法预测Baseline偏置值</p>
<h6 id="step-1：梯度下降法推导"><a href="#step-1：梯度下降法推导" class="headerlink" title="step 1：梯度下降法推导"></a>step 1：梯度下降法推导</h6><p>损失函数：<br>$$<br>\begin{split}<br>&amp;J(\theta)&#x3D;Cost&#x3D;f(b_u, b_i)\<br>\<br>&amp;J(\theta)&#x3D;\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>\end{split}<br>$$<br>梯度下降参数更新原始公式：<br>$$<br>\theta_j:&#x3D;\theta_j-\alpha\cfrac{\partial }{\partial \theta_j}J(\theta)<br>$$<br>梯度下降更新$b_u$:</p>
<p>​	损失函数偏导推导：<br>$$<br>\begin{split}<br>\cfrac{\partial}{\partial b_u} J(\theta)&amp;&#x3D;\cfrac{\partial}{\partial b_u} f(b_u, b_i)<br>\&amp;&#x3D;2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)(-1) + 2\lambda{b_u}<br>\&amp;&#x3D;-2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda<em>b_u<br>\end{split}<br>$$<br>​	$b_u$更新(因为alpha可以人为控制，所以2可以省略掉)：<br>$$<br>\begin{split}<br>b_u&amp;:&#x3D;b_u - \alpha</em>(-\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + \lambda * b_u)\<br>&amp;:&#x3D;b_u + \alpha*(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) - \lambda* b_u)<br>\end{split}<br>$$<br>同理可得，梯度下降更新$b_i$:<br>$$<br>b_i:&#x3D;b_i + \alpha*(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) -\lambda*b_i)<br>$$</p>
<h6 id="step-2：随机梯度下降"><a href="#step-2：随机梯度下降" class="headerlink" title="step 2：随机梯度下降"></a>step 2：随机梯度下降</h6><p>由于<strong>随机梯度下降法</strong>本质上利用<strong>每个样本的损失</strong>来更新参数，而不用每次求出全部的损失和，因此使用SGD时：</p>
<p>单样本损失值：<br>$$<br>\begin{split}<br>error &amp;&#x3D;r_{ui}-\hat{r}<em>{ui}<br>\&amp;&#x3D; r</em>{ui}-(\mu+b_u+b_i)<br>\&amp;&#x3D; r_{ui}-\mu-b_u-b_i<br>\end{split}<br>$$<br>参数更新：<br>$$<br>\begin{split}<br>b_u&amp;:&#x3D;b_u + \alpha*((r_{ui}-\mu-b_u-b_i) -\lambda<em>b_u)  \<br>&amp;:&#x3D;b_u + \alpha</em>(error - \lambda<em>b_u) \<br>\<br>b_i&amp;:&#x3D;b_i + \alpha</em>((r_{ui}-\mu-b_u-b_i) -\lambda<em>b_i)\<br>&amp;:&#x3D;b_i + \alpha</em>(error -\lambda*b_i)<br>\end{split}<br>$$</p>
<h6 id="step-3：算法实现"><a href="#step-3：算法实现" class="headerlink" title="step 3：算法实现"></a>step 3：算法实现</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaselineCFBySGD</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number_epochs, alpha, reg, columns=[<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;iid&quot;</span>, <span class="string">&quot;rating&quot;</span>]</span>):</span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, dataset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.users_ratings.index, np.zeros(<span class="built_in">len</span>(self.users_ratings))))</span><br><span class="line">        bi = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.items_ratings.index, np.zeros(<span class="built_in">len</span>(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;iter%d&quot;</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line"></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, uid, iid</span>):</span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dtype = [(<span class="string">&quot;userId&quot;</span>, np.int32), (<span class="string">&quot;movieId&quot;</span>, np.int32), (<span class="string">&quot;rating&quot;</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">&quot;datasets/ml-latest-small/ratings.csv&quot;</span>, usecols=<span class="built_in">range</span>(<span class="number">3</span>), dtype=<span class="built_in">dict</span>(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;movieId&quot;</span>, <span class="string">&quot;rating&quot;</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;uid: &quot;</span>))</span><br><span class="line">        iid = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;iid: &quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure>

<h6 id="Step-4-准确性指标评估"><a href="#Step-4-准确性指标评估" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><ul>
<li>添加test方法，然后使用之前实现accuary方法计算准确性指标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_split</span>(<span class="params">data_path, x=<span class="number">0.8</span>, random=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始切分数据集...&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">&quot;userId&quot;</span>: np.int32, <span class="string">&quot;movieId&quot;</span>: np.int32, <span class="string">&quot;rating&quot;</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">&quot;userId&quot;</span>).<span class="built_in">any</span>().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">&quot;userId&quot;</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = <span class="built_in">list</span>(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = <span class="built_in">round</span>(<span class="built_in">len</span>(user_rating_data) * x)</span><br><span class="line">            testset_index += <span class="built_in">list</span>(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = <span class="built_in">round</span>(<span class="built_in">len</span>(user_rating_data) * x)</span><br><span class="line">            testset_index += <span class="built_in">list</span>(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;完成数据集切分...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuray</span>(<span class="params">predict_results, method=<span class="string">&quot;all&quot;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mae</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += <span class="built_in">abs</span>(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rmse_mae</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += <span class="built_in">abs</span>(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(np.sqrt(_rmse_sum / length), <span class="number">4</span>), <span class="built_in">round</span>(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">&quot;rmse&quot;</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">&quot;mae&quot;</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaselineCFBySGD</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number_epochs, alpha, reg, columns=[<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;iid&quot;</span>, <span class="string">&quot;rating&quot;</span>]</span>):</span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, dataset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.users_ratings.index, np.zeros(<span class="built_in">len</span>(self.users_ratings))))</span><br><span class="line">        bi = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.items_ratings.index, np.zeros(<span class="built_in">len</span>(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;iter%d&quot;</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line"></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, uid, iid</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;评分预测&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据&quot;</span>.<span class="built_in">format</span>(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self,testset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;预测测试集数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    trainset, testset = data_split(<span class="string">&quot;datasets/ml-latest-small/ratings.csv&quot;</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;movieId&quot;</span>, <span class="string">&quot;rating&quot;</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rmse: &quot;</span>, rmse, <span class="string">&quot;mae: &quot;</span>, mae)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方法二：交替最小二乘法优化"><a href="#方法二：交替最小二乘法优化" class="headerlink" title="方法二：交替最小二乘法优化"></a>方法二：交替最小二乘法优化</h4><p>使用交替最小二乘法优化算法预测Baseline偏置值</p>
<h6 id="step-1-交替最小二乘法推导"><a href="#step-1-交替最小二乘法推导" class="headerlink" title="step 1: 交替最小二乘法推导"></a>step 1: 交替最小二乘法推导</h6><p>最小二乘法和梯度下降法一样，可以用于求极值。</p>
<p><strong>最小二乘法思想：对损失函数求偏导，然后再使偏导为0</strong></p>
<p>同样，损失函数：<br>$$<br>J(\theta)&#x3D;\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>对损失函数求偏导：<br>$$<br>\cfrac{\partial}{\partial b_u} f(b_u, b_i) &#x3D;-2 \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda * b_u<br>$$<br>令偏导为0，则可得：<br>$$<br>\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) &#x3D; \lambda* b_u<br>\\sum_{u,i\in R}(r_{ui}-\mu-b_i) &#x3D; \sum_{u,i\in R} b_u+\lambda * b_u<br>$$<br><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211012163348404.png" alt="image-20211012163348404"><br>$$<br>b_u :&#x3D; \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_i)}{\lambda_1 + |R(u)|}<br>$$<br>其中$|R(u)|$表示用户$u$的有过评分数量</p>
<p>同理可得：<br>$$<br>b_i :&#x3D; \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_u)}{\lambda_2 + |R(i)|}<br>$$<br>其中$|R(i)|$表示物品$i$收到的评分数量</p>
<p>$b_u$和$b_i$分别属于用户和物品的偏置，因此他们的正则参数可以分别设置两个独立的参数</p>
<h6 id="step-2-交替最小二乘法应用"><a href="#step-2-交替最小二乘法应用" class="headerlink" title="step 2: 交替最小二乘法应用"></a>step 2: 交替最小二乘法应用</h6><p>通过最小二乘推导，我们最终分别得到了$b_u$和$b_i$的表达式，但他们的表达式中却又各自包含对方，因此这里我们将利用一种叫交替最小二乘的方法来计算他们的值：	</p>
<ul>
<li>计算其中一项，先固定其他未知参数，即看作其他未知参数为已知</li>
<li>如求$b_u$时，将$b_i$看作是已知；求$b_i$时，将$b_u$看作是已知；如此反复交替，不断更新二者的值，求得最终的结果。这就是<strong>交替最小二乘法（ALS）</strong></li>
</ul>
<h6 id="step-3-算法实现"><a href="#step-3-算法实现" class="headerlink" title="step 3: 算法实现"></a>step 3: 算法实现</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaselineCFByALS</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;iid&quot;</span>, <span class="string">&quot;rating&quot;</span>]</span>):</span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, dataset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">als</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.users_ratings.index, np.zeros(<span class="built_in">len</span>(self.users_ratings))))</span><br><span class="line">        bi = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.items_ratings.index, np.zeros(<span class="built_in">len</span>(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;iter%d&quot;</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> <span class="built_in">zip</span>(uids, ratings):</span><br><span class="line">                    _<span class="built_in">sum</span> += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _<span class="built_in">sum</span> / (self.reg_bi + <span class="built_in">len</span>(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> <span class="built_in">zip</span>(iids, ratings):</span><br><span class="line">                    _<span class="built_in">sum</span> += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _<span class="built_in">sum</span> / (self.reg_bu + <span class="built_in">len</span>(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, uid, iid</span>):</span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dtype = [(<span class="string">&quot;userId&quot;</span>, np.int32), (<span class="string">&quot;movieId&quot;</span>, np.int32), (<span class="string">&quot;rating&quot;</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">&quot;datasets/ml-latest-small/ratings.csv&quot;</span>, usecols=<span class="built_in">range</span>(<span class="number">3</span>), dtype=<span class="built_in">dict</span>(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;movieId&quot;</span>, <span class="string">&quot;rating&quot;</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;uid: &quot;</span>))</span><br><span class="line">        iid = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;iid: &quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure>

<h6 id="Step-4-准确性指标评估-1"><a href="#Step-4-准确性指标评估-1" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_split</span>(<span class="params">data_path, x=<span class="number">0.8</span>, random=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始切分数据集...&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">&quot;userId&quot;</span>: np.int32, <span class="string">&quot;movieId&quot;</span>: np.int32, <span class="string">&quot;rating&quot;</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">&quot;userId&quot;</span>).<span class="built_in">any</span>().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">&quot;userId&quot;</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = <span class="built_in">list</span>(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = <span class="built_in">round</span>(<span class="built_in">len</span>(user_rating_data) * x)</span><br><span class="line">            testset_index += <span class="built_in">list</span>(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = <span class="built_in">round</span>(<span class="built_in">len</span>(user_rating_data) * x)</span><br><span class="line">            testset_index += <span class="built_in">list</span>(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;完成数据集切分...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuray</span>(<span class="params">predict_results, method=<span class="string">&quot;all&quot;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mae</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += <span class="built_in">abs</span>(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rmse_mae</span>(<span class="params">predict_results</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += <span class="built_in">abs</span>(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(np.sqrt(_rmse_sum / length), <span class="number">4</span>), <span class="built_in">round</span>(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">&quot;rmse&quot;</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">&quot;mae&quot;</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaselineCFByALS</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;iid&quot;</span>, <span class="string">&quot;rating&quot;</span>]</span>):</span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, dataset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([<span class="built_in">list</span>])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">als</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.users_ratings.index, np.zeros(<span class="built_in">len</span>(self.users_ratings))))</span><br><span class="line">        bi = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.items_ratings.index, np.zeros(<span class="built_in">len</span>(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;iter%d&quot;</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> <span class="built_in">zip</span>(uids, ratings):</span><br><span class="line">                    _<span class="built_in">sum</span> += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _<span class="built_in">sum</span> / (self.reg_bi + <span class="built_in">len</span>(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> <span class="built_in">zip</span>(iids, ratings):</span><br><span class="line">                    _<span class="built_in">sum</span> += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _<span class="built_in">sum</span> / (self.reg_bu + <span class="built_in">len</span>(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, uid, iid</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;评分预测&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据&quot;</span>.<span class="built_in">format</span>(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self,testset</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;预测测试集数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    trainset, testset = data_split(<span class="string">&quot;datasets/ml-latest-small/ratings.csv&quot;</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;movieId&quot;</span>, <span class="string">&quot;rating&quot;</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rmse: &quot;</span>, rmse, <span class="string">&quot;mae: &quot;</span>, mae)</span><br></pre></td></tr></table></figure>

<p>函数求导：</p>
<p><img src="/img/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC.png"></p>
<p><img src="/img/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97.png"></p>
]]></content>
      <categories>
        <category>传统推荐</category>
      </categories>
      <tags>
        <tag>回归模型</tag>
        <tag>协同过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统简介</title>
    <url>/2023/09/23/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="一-推荐系统简介">一 推荐系统简介</h2>
<p>​ 个性化推荐(推荐系统)经历了多年的发展，已经成为互联网产品的标配，也是AI成功落地的分支之一，在电商(淘宝/京东)、资讯(今日头条/微博)、音乐(网易云音乐/QQ音乐)、短视频(抖音/快手)等热门应用中,推荐系统都是核心组件之一。</p>
<ul>
<li>推荐系统产生背景 <span id="more"></span>
<ul>
<li>信息过载 &amp; 用户需求不明确
<ul>
<li>分类⽬录（1990s）：覆盖少量热门⽹站。Hao123 Yahoo</li>
<li>搜索引擎（2000s）：通过搜索词明确需求。Google Baidu</li>
<li>推荐系统（2010s）：不需要⽤户提供明确的需求，通过分析⽤ 户的历史⾏为给⽤户的兴趣进⾏建模，从⽽主动给⽤户推荐能 够满⾜他们兴趣和需求的信息。</li>
</ul></li>
</ul></li>
<li><p>什么是推荐系统</p>
<ul>
<li>没有明确需求的用户访问了我们的服务, 且服务的物品对用户构成了信息过载, 系统通过一定的规则对物品进行排序,并将排在前面的物品展示给用户,这样的系统就是推荐系统</li>
</ul></li>
<li><p>推荐系统 V.S. 搜索引擎</p>
<table>
<tr>
<th>
</th>
<th>
搜索
</th>
<th>
推荐
</th>
</tr>
<tr>
<td>
行为方式
</td>
<td>
主动
</td>
<td>
被动
</td>
</tr>
<tr>
<td>
意图
</td>
<td>
明确
</td>
<td>
模糊
</td>
</tr>
<tr>
<td>
个性化
</td>
<td>
弱
</td>
<td>
强
</td>
</tr>
<tr>
<td>
流量分布
</td>
<td>
马太效应
</td>
<td>
长尾效应
</td>
</tr>
<tr>
<td>
目标
</td>
<td>
快速满足
</td>
<td>
持续服务
</td>
</tr>
<tr>
<td>
评估指标
</td>
<td>
简明
</td>
<td>
复杂
</td>
</tr>
</table></li>
<li><p>推荐系统的作用</p>
<ul>
<li>高效连接用户和物品, 发现长尾商品</li>
<li>留住用户和内容生产者, 实现商业目标</li>
</ul></li>
<li><p>推荐系统的工作原理</p>
<ul>
<li><strong>社会化推荐</strong> 向朋友咨询, 社会化推荐, 让好友给自己推荐物品</li>
<li><strong>基于内容的推荐</strong> 打开搜索引擎, 输入自己喜欢的演员的名字, 然后看看返回结果中还有什么电影是自己没看过的</li>
<li><strong>基于流行度的推荐</strong> 查看票房排行榜,</li>
<li><strong>基于协同过滤的推荐</strong> 找到和自己历史兴趣相似的用户, 看看他们最近在看什么电影</li>
</ul></li>
<li><p>推荐系统的应用场景 feed 流 信息流</p>
<p><img src="https://pic.imgdb.cn/item/650ec1e1c458853aef155858.png" /></p></li>
<li><p>推荐系统和Web项目的区别</p>
<ul>
<li>稳定的信息流通系统 V.S. 通过信息过滤实现目标提升
<ul>
<li>web项目: 处理复杂逻辑 处理高并发 实现高可用 为用户提供稳定服务, 构建一个稳定的信息流通的服务</li>
<li>推荐系统: 追求指标增长, 留存率/阅读时间/GMV (Gross Merchandise Volume电商网站成交金额)/视频网站VV (Video View)</li>
</ul></li>
<li>确定 V.S. 不确定思维
<ul>
<li>web项目: 对结果有确定预期</li>
<li>推荐系统: 结果是概率问题</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>简介</category>
      </categories>
      <tags>
        <tag>推荐系统简介</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统架构</title>
    <url>/2023/09/24/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="二-推荐系统设计">二 推荐系统设计</h2>
<h3 id="推荐系统要素">2.1 推荐系统要素</h3>
<ul>
<li>UI 和 UE(前端界面)</li>
<li>数据 (Lambda架构)</li>
<li>业务知识</li>
<li>算法</li>
</ul>
<span id="more"></span>
<h3 id="推荐系统架构">2.2 推荐系统架构</h3>
<ul>
<li>推荐系统整体架构</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6510012bc458853aef738bc5.png" /></p>
<ul>
<li><p>大数据Lambda架构</p>
<ul>
<li><p>由Twitter工程师Nathan Marz(storm项目发起人)提出</p></li>
<li><p>Lambda系统架构提供了一个结合实时数据和Hadoop预先计算的数据环境和混合平台, 提供一个实时的数据视图</p></li>
<li><p>分层架构</p>
<ul>
<li>批处理层
<ul>
<li>数据不可变, 可进行任何计算, 可水平扩展</li>
<li>高延迟 几分钟~几小时(计算量和数据量不同)</li>
<li>日志收集 Flume</li>
<li>分布式存储 Hadoop hdfs</li>
<li>分布式计算 Hadoop MapReduce &amp; spark</li>
<li>视图存储数据库
<ul>
<li>nosql(HBase/Cassandra)</li>
<li>Redis/memcache</li>
<li>MySQL</li>
</ul></li>
</ul></li>
<li>实时处理层
<ul>
<li>流式处理, 持续计算</li>
<li>存储和分析某个窗口期内的数据</li>
<li>最终正确性(Eventual accuracy)</li>
<li>实时数据收集 flume &amp; kafka</li>
<li>实时数据分析 spark streaming/storm/flink</li>
</ul></li>
<li>服务层
<ul>
<li>支持随机读</li>
<li>需要在非常短的时间内返回结果</li>
<li>读取批处理层和实时处理层结果并对其归并</li>
</ul></li>
</ul></li>
<li><p>Lambda架构图</p></li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6510018ac458853aef739b7b.png" /></p>
<ul>
<li><p>推荐算法架构</p>
<ul>
<li>召回阶段(海选)
<ul>
<li>召回决定了最终推荐结果的天花板</li>
<li>常用算法:
<ul>
<li>协同过滤(基于用户 基于物品的)</li>
<li>基于内容 (根据用户行为总结出自己的偏好 根据偏好 通过文本挖掘技术找到内容上相似的商品)</li>
<li>基于隐语义</li>
</ul></li>
</ul></li>
<li>排序阶段
<ul>
<li>召回决定了最终推荐结果的天花板, 排序逼近这个极限, 决定了最终的推荐效果</li>
<li>CTR预估 (点击率预估 使用LR算法) 估计用户是否会点击某个商品 需要用户的点击数据</li>
</ul></li>
<li>策略调整</li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/651001a3c458853aef73a085.jpg" /></p>
<ul>
<li>推荐系统的整体架构</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6510023cc458853aef745c0d.png" /></p>
<p><img src="https://pic.imgdb.cn/item/65100252c458853aef747541.png" /></p>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐算法</title>
    <url>/2023/09/26/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="推荐算法">推荐算法</h2>
<ul>
<li>推荐模型构建流程</li>
<li>推荐算法概述</li>
<li>基于协同过滤的推荐算法</li>
<li>协同过滤实现 <span id="more"></span></li>
</ul>
<h3 id="一-推荐模型构建流程">一 推荐模型构建流程</h3>
<p>Data(数据)-&gt;Features(特征)-&gt;ML Algorithm(机器学习算法)-&gt;Prediction Output(预测输出)</p>
<ul>
<li>数据清洗/数据处理</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c517c458853aeff0100e.png" /></p>
<ul>
<li>数据来源
<ul>
<li>显性数据
<ul>
<li>Rating 打分</li>
<li>Comments 评论/评价</li>
</ul></li>
<li>隐形数据
<ul>
<li> Order history 历史订单</li>
<li> Cart events 加购物车</li>
<li> Page views 页面浏览</li>
<li> Click-thru 点击</li>
<li> Search log 搜索记录</li>
</ul></li>
</ul></li>
<li>数据量/数据能否满足要求</li>
<li>特征工程</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c52cc458853aeff0120a.png" /></p>
<ul>
<li>从数据中筛选特征
<ul>
<li>一个给定的商品，可能被拥有类似品味或需求的用户购买</li>
<li>使用用户行为数据描述商品</li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c53dc458853aeff01401.png" /></p>
<ul>
<li><p>用数据表示特征</p>
<ul>
<li><p>将所有用户行为合并在一起 ，形成一个user-item 矩阵</p>
<p><img src="https://pic.imgdb.cn/item/6512c54fc458853aeff01626.png" /></p></li>
</ul></li>
<li><p>选择合适的算法</p></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c595c458853aeff0202e.png" /></p>
<ul>
<li><p>产生推荐结果</p>
<p><img src="https://pic.imgdb.cn/item/6512c5a4c458853aeff02488.png" /></p></li>
</ul>
<h3 id="二-最经典的推荐算法协同过滤推荐算法collaborative-filtering">二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</h3>
<p>算法思想：<strong>物以类聚，人以群分</strong></p>
<p>基本的协同过滤推荐算法基于以下假设：</p>
<ul>
<li>“跟你喜好<strong>相似的人</strong>喜欢的东西你也很有可能喜欢” ：基于用户的协同过滤推荐（User-based CF）</li>
<li>“跟你喜欢的东西<strong>相似的东西</strong>你也很有可能喜欢 ”：基于物品的协同过滤推荐（Item-based CF）</li>
</ul>
<p>实现协同过滤推荐有以下几个步骤：</p>
<ol type="1">
<li><p><strong>找出最相似的人或物品：TOP-N相似的人或物品</strong></p>
<p>通过计算两两的相似度来进行排序，即可找出TOP-N相似的人或物品</p></li>
<li><p><strong>根据相似的人或物品产生推荐结果</strong></p>
<p>利用TOP-N结果生成初始推荐结果，然后过滤掉用户已经有过记录的物品或明确表示不感兴趣的物品</p></li>
</ol>
<p>以下是一个简单的示例，数据集相当于一个用户对物品的购买记录表：打勾表示用户对物品的有购买记录</p>
<ul>
<li><p>关于相似度计算这里先用一个简单的思想：如有两个同学X和Y，X同学爱好[足球、篮球、乒乓球]，Y同学爱好[网球、足球、篮球、羽毛球]，可见他们的共同爱好有2个，那么他们的相似度可以用：2/3 * 2/4 = 1/3 ≈ 0.33 来表示。</p>
<p><strong>User-Based CF</strong></p>
<p><img src="https://pic.imgdb.cn/item/6512c64ac458853aeff0429c.png" /></p>
<p><strong>Item-Based CF</strong></p>
<p><img src="https://pic.imgdb.cn/item/6512c5c8c458853aeff02a74.png" /></p>
<p>通过前面两个demo，相信大家应该已经对协同过滤推荐算法的设计与实现有了比较清晰的认识。</p></li>
</ul>
<h3 id="三-相似度计算similarity-calculation">三 相似度计算(Similarity Calculation)</h3>
<p><img src="https://pic.imgdb.cn/item/6512c697c458853aeff04bba.png" /></p>
<ul>
<li><p>相似度的计算方法</p>
<ul>
<li>数据分类
<ul>
<li>实数值(物品评分情况)</li>
<li>布尔值(用户的行为 是否点击 是否收藏)</li>
</ul></li>
<li>欧氏距离, 是一个欧式空间下度量距离的方法. 两个物体, 都在同一个空间下表示为两个点, 假如叫做p,q, 分别都是n个坐标, 那么欧式距离就是衡量这两个点之间的距离. 欧氏距离不适用于布尔向量之间</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c70dc458853aeff059ba.png" /> <span class="math display">\[
E(p,q) = \sqrt{\sum_{i=1}^n (p_i - q_i)^2}
\]</span></p>
<p>​ 欧氏距离的值是一个非负数, 最大值正无穷, 通常计算相似度的结果希望是[-1,1]或[0,1]之间,一般可以使用</p>
<p>​ 如下转化公式:<img src="https://pic.imgdb.cn/item/6512ca38c458853aeff19c92.png" /></p>
<p>​</p></li>
<li>杰卡德相似度&amp;余弦相似度&amp;皮尔逊相关系数
<ul>
<li>余弦相似度
<ul>
<li>度量的是两个向量之间的夹角, 用夹角的余弦值来度量相似的情况</li>
<li>两个向量的夹角为0是,余弦值为1, 当夹角为90度是余弦值为0,为180度是余弦值为-1</li>
<li>余弦相似度在度量文本相似度, 用户相似度 物品相似度的时候较为常用</li>
<li>余弦相似度的特点, 与向量长度无关,余弦相似度计算要对向量长度归一化, 两个向量只要方向一致,无论程度强弱, 都可以视为'相似'</li>
</ul></li>
<li>皮尔逊相关系数Pearson
<ul>
<li>实际上也是一种余弦相似度, 不过先对向量做了中心化, 向量a b 各自减去向量的均值后, 再计算余弦相似度</li>
<li>皮尔逊相似度计算结果在-1,1之间 -1表示负相关, 1表示正相关</li>
<li>度量两个变量是不是同增同减</li>
<li>皮尔逊相关系数度量的是两个变量的变化趋势是否一致, <strong>不适合计算布尔值向量之间的相关度</strong></li>
</ul></li>
<li>杰卡德相似度 Jaccard
<ul>
<li>两个集合的交集元素个数在并集中所占的比例, 非常适用于布尔向量表示</li>
<li>分子是两个布尔向量做点积计算, 得到的就是交集元素的个数</li>
<li>分母是两个布尔向量做或运算, 再求元素和</li>
</ul></li>
<li>余弦相似度适合用户评分数据(实数值), 杰卡德相似度适用于隐式反馈数据(0,1布尔值)(是否收藏,是否点击,是否加购物车)</li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c72bc458853aeff05ce1.png" /></p>
<ul>
<li><p>余弦相似度</p>
<p><img src="https://pic.imgdb.cn/item/6512c747c458853aeff06095.png" /></p></li>
<li><p>皮尔逊相关系数</p></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c762c458853aeff063c2.png" /></p>
<p><img src="https://pic.imgdb.cn/item/6512c771c458853aeff06544.png" /></p>
<ul>
<li>计算出用户1和其它用户之间的相似度</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c77dc458853aeff066a3.png" /></p>
<ul>
<li>按照相似度大小排序, K近邻 如K取4:</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c78bc458853aeff06975.png" /></p>
<ul>
<li>取出近邻用户的购物清单</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c799c458853aeff06ac7.png" /></p>
<ul>
<li>去除用户1已经购买过的商品</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7a5c458853aeff06bad.png" /></p>
<ul>
<li>在剩余的物品中根据评分排序</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7b2c458853aeff0b6c3.png" /></p>
<ul>
<li>物品相似度计算
<ul>
<li>余弦相似度对绝对值大小不敏感带来的问题
<ul>
<li>用户A对两部电影评分分别是1分和2分, 用户B对同样这两部电影进行评分是4分,5分 用余弦相似度计算,两个用户的相似度达到0.98<br />
</li>
<li>可以采用改进的余弦相似度, 先计算向量每个维度上的均值, 然后每个向量在各个维度上都减去均值后,在计算余弦相似度, 用调整的余弦相似度计算得到的相似度是-0.1</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7bec458853aeff0bc0d.png" /></p>
<ul>
<li>物品相似度计算案例</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7c9c458853aeff0be8c.png" /></p>
<ul>
<li>找出物品1的相似商品</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7dac458853aeff0c41a.png" /></p>
<ul>
<li>选择最近似的物品</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c7fac458853aeff0ca27.png" /></p>
<ul>
<li>基于用户与物品的协同过滤比较</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c809c458853aeff0ce46.png" /><img src="https://pic.imgdb.cn/item/6512c817c458853aeff0d2a5.png" /></p>
<h3 id="协同过滤推荐算法代码实现">协同过滤推荐算法代码实现：</h3>
<ul>
<li><p>构建数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>计算时我们数据通常都需要对数据进行处理，或者编码，目的是为了便于我们对数据进行运算处理，比如这里是比较简单的情形，我们用1、0分别来表示用户的是否购买过该物品，则我们的数据集其实应该是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></li>
<li><p>有了数据集，接下来我们就可以进行相似度的计算，不过对于相似度的计算其实是有很多专门的相似度计算方法的，比如余弦相似度、皮尔逊相关系数、杰卡德相似度等等。这里我们选择使用杰卡德相似系数[0,1]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接计算某两项的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line"><span class="comment"># 计算Item A 和Item B的相似度</span></span><br><span class="line"><span class="built_in">print</span>(jaccard_similarity_score(df[<span class="string">&quot;Item A&quot;</span>], df[<span class="string">&quot;Item B&quot;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_similar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(item_similar)</span><br></pre></td></tr></table></figure>
<p>有了两两的相似度，接下来就可以筛选TOP-N相似结果，并进行推荐了</p></li>
<li><p>User-Based CF</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_similar)</span><br><span class="line"></span><br><span class="line">topN_users = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> user_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = user_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_users[i] = top2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top2相似用户：&quot;</span>)</span><br><span class="line">pprint(topN_users)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user, sim_users <span class="keyword">in</span> topN_users.items():</span><br><span class="line">    rs_result = <span class="built_in">set</span>()    <span class="comment"># 存储推荐结果</span></span><br><span class="line">    <span class="keyword">for</span> sim_user <span class="keyword">in</span> sim_users:</span><br><span class="line">        <span class="comment"># 构建初始的推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(<span class="built_in">set</span>(df.ix[sim_user].replace(<span class="number">0</span>,np.nan).dropna().index))</span><br><span class="line">    <span class="comment"># 过滤掉已经购买过的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li>
<li><p>Item-Based CF</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(item_similar)</span><br><span class="line"></span><br><span class="line">topN_items = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> item_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = item_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_items[i] = top2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top2相似物品：&quot;</span>)</span><br><span class="line">pprint(topN_items)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> df.index:    <span class="comment"># 遍历所有用户</span></span><br><span class="line">    rs_result = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index:   <span class="comment"># 取出每个用户当前已购物品列表</span></span><br><span class="line">        <span class="comment"># 根据每个物品找出最相似的TOP-N物品，构建初始推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(topN_items[item])</span><br><span class="line">    <span class="comment"># 过滤掉用户已购的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    <span class="comment"># 添加到结果中</span></span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关于协同过滤推荐算法使用的数据集</strong></p>
<p>在前面的demo中，我们只是使用用户对物品的一个购买记录，类似也可以是比如浏览点击记录、收听记录等等。这样数据我们预测的结果其实相当于是在预测用户是否对某物品感兴趣，对于喜好程度不能很好的预测。</p>
<p>因此在协同过滤推荐算法中其实会更多的利用用户对物品的“评分”数据来进行预测，通过评分数据集，我们可以预测用户对于他没有评分过的物品的评分。其实现原理和思想和都是一样的，只是使用的数据集是用户-物品的评分数据。</p>
<p><strong>关于用户-物品评分矩阵</strong></p>
<p>用户-物品的评分矩阵，根据评分矩阵的稀疏程度会有不同的解决方案</p>
<ul>
<li><p>稠密评分矩阵</p>
<p><img src="https://pic.imgdb.cn/item/6512c863c458853aeff0ee76.png" /></p></li>
<li><p>稀疏评分矩阵</p>
<p><img src="https://pic.imgdb.cn/item/6512c87ac458853aeff0f598.png" /></p></li>
</ul>
<p>这里先介绍稠密评分矩阵的处理，稀疏矩阵的处理相对会复杂一些，我们到后面再来介绍。</p>
<h4 id="使用协同过滤推荐算法对用户进行评分预测">使用协同过滤推荐算法对用户进行评分预测</h4>
<ul>
<li><p>数据集：<img src="https://pic.imgdb.cn/item/6512c8c5c458853aeff0fd23.jpg" /></p>
<p><strong>目的：预测用户1对物品E的评分</strong></p></li>
<li><p>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p>
<blockquote>
<p>pandas中corr方法可直接用于计算皮尔逊相关系数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line"><span class="built_in">print</span>(user_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line"><span class="built_in">print</span>(item_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行结果：</span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  1.0000  0.8528  0.7071  0.0000 -0.7921</span><br><span class="line">User2  0.8528  1.0000  0.4677  0.4900 -0.9001</span><br><span class="line">User3  0.7071  0.4677  1.0000 -0.1612 -0.4666</span><br><span class="line">User4  0.0000  0.4900 -0.1612  1.0000 -0.6415</span><br><span class="line">User5 -0.7921 -0.9001 -0.4666 -0.6415  1.0000</span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  1.0000 -0.4767 -0.1231  0.5322  0.9695</span><br><span class="line">Item B -0.4767  1.0000  0.6455 -0.3101 -0.4781</span><br><span class="line">Item C -0.1231  0.6455  1.0000 -0.7206 -0.4276</span><br><span class="line">Item D  0.5322 -0.3101 -0.7206  1.0000  0.5817</span><br><span class="line">Item E  0.9695 -0.4781 -0.4276  0.5817  1.0000</span><br></pre></td></tr></table></figure>
<p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p>
<p><strong>注意：</strong>我们在预测评分时，往往是通过与其有正相关的用户或物品进行预测，如果不存在正相关的情况，那么将无法做出预测。这一点尤其是在稀疏评分矩阵中尤为常见，因为稀疏评分矩阵中很难得出正相关系数。</p></li>
<li><p><strong>评分预测：</strong></p>
<p><strong>User-Based CF 评分预测：使用用户间的相似度进行预测</strong></p>
<p>关于评分预测的方法也有比较多的方案，下面介绍一种效果比较好的方案，该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测： <span class="math display">\[
pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}
\]</span> 我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p>
<p>​ <span class="math display">\[
pred(u_1, i_5) =\cfrac{0.85*3+0.71*5}{0.85+0.71} = 3.91
\]</span> 最终预测出用户1对物品5的评分为3.91</p>
<p><strong>Item-Based CF 评分预测：使用物品间的相似度进行预测</strong></p>
<p>这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测 <span class="math display">\[
pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}
\]</span> 我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下： <span class="math display">\[
pred(u_1, i_5) = \cfrac {0.97*5+0.58*4}{0.97+0.58} = 4.63
\]</span> 对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法，各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估，因此在实现推荐系统时这两种算法往往都是需要去实现的，然后对产生的推荐效果进行评估分析选出更优方案。</p></li>
</ul>
<h3 id="基于模型的方法">基于模型的方法</h3>
<ul>
<li>思想
<ul>
<li>通过机器学习算法，在数据中找出模式，并将用户与物品间的互动方式模式化</li>
<li>基于模型的协同过滤方式是构建协同过滤更高级的算法</li>
</ul></li>
<li><p>近邻模型的问题</p>
<ul>
<li>物品之间存在相关性, 信息量并不随着向量维度增加而线性增加</li>
<li>矩阵元素稀疏, 计算结果不稳定,增减一个向量维度, 导致近邻结果差异很大的情况存在</li>
</ul></li>
<li>算法分类
<ul>
<li>基于图的模型</li>
<li><strong>基于矩阵分解的方法</strong></li>
</ul></li>
<li><p>基于图的模型</p>
<ul>
<li>基于邻域的模型看做基于图的模型的简单形式</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6512c8e0c458853aeff10008.png" /></p>
<ul>
<li>原理
<ul>
<li>将用户的行为数据表示为二分图</li>
<li>基于二分图为用户进行推荐</li>
<li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li>
</ul></li>
</ul></li>
<li><p>基于矩阵分解的模型</p>
<ul>
<li><p>原理</p>
<ul>
<li><p>根据用户与物品的潜在表现，我们就可以预测用户对未评分的物品的喜爱程度</p></li>
<li><p>把原来的大矩阵, 近似分解成两个小矩阵的乘积, 在实际推荐计算时不再使用大矩阵, 而是使用分解得到的两个小矩阵</p></li>
<li><p>用户-物品评分矩阵A是M X N维, 即一共有M个用户, n个物品 我们选一个很小的数 K (K&lt;&lt; M, K&lt;&lt;N)</p></li>
<li><p>通过计算得到两个矩阵U V U是M * K矩阵 , 矩阵V是 N * K</p>
<p><span class="math inline">\(U_{m*k} V^{T}_{n*k} 约等于 A_{m*n}\)</span></p>
<p>类似这样的计算过程就是矩阵分解</p></li>
</ul></li>
<li>基于矩阵分解的方法
<ul>
<li>ALS交替最小二乘
<ul>
<li>ALS-WR(加权正则化交替最小二乘法): alternating-least-squares with weighted-λ –regularization</li>
<li>将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户做商品推荐了。</li>
</ul></li>
<li>SVD奇异值分解矩阵</li>
</ul></li>
</ul></li>
<li><p>ALS方法</p>
<p><img src="https://pic.imgdb.cn/item/6512c8fec458853aeff102ef.png" /></p>
<ul>
<li>ALS的矩阵分解算法常应用于推荐系统中，将用户(user)对商品(item)的评分矩阵，分解为用户对商品隐含特征的偏好矩阵，和商品在隐含特征上的映射矩阵。</li>
<li>与传统的矩阵分解SVD方法来分解矩阵R(R∈ℝm×n)不同的是，ALS(alternating least squares)希望找到两个低维矩阵，以 R̃ =XY 来逼近矩阵R，其中 ，X∈ℝm×d，Y∈ℝd×n，这样，将问题的复杂度由O(m<em>n)转换为O((m+n)</em>d)。</li>
<li>计算X和Y过程：首先用一个小于1的随机数初始化Y，并根据公式求X，此时就可以得到初始的XY矩阵了，根据平方差和得到的X，重新计算并覆盖Y，计算差平方和，反复进行以上两步的计算，直到差平方和小于一个预设的数，或者迭代次数满足要求则停止</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>算法介绍</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简介</tag>
      </tags>
  </entry>
</search>
